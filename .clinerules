### BEGIN LANGUAGE_AGNOSTIC

# System Environment

OS: Windows
Shell: Windows PowerShell

# Shell Limitations

PowerShell does not support && to combine commands.
For example this will not work:
python -m venv venv && .venv\Scripts\activate
Execute commands separately.

# Project Structure

- Keep a concise README.md explaining setup and usage
- Group related functionality into separate modules
- Store configuration in settings.ini at project root

# Documentation & Automation

Provide .bat files for automation:
install.bat:
python -m venv venv
venv\Scripts\activate
pip install -r requirements.txt

run.bat:
venv\Scripts\activate
python main.py

### BEGIN PYTHON_HINTS

# Coding Standards

- Follow PEP 8 style guidelines
- Use docstrings and type hints
- Auto-format code with black
- Use flake8 for linting

# Virtual Environments

- Create venv for dependency isolation
- Maintain requirements.txt
- Use latest stable versions of packages

# Logging Best Practices

- Use Python's logging module
- Avoid print statements
- Handle exceptions with proper error messages
- Use appropriate log levels (INFO, WARNING, ERROR)

# Entry Points

- Use main.py for argument parsing and flow
- Use if **name** == "**main**" pattern
- Import modules as needed

### BEGIN JAVASCRIPT_HINTS

# Frontend Organization

- Keep JavaScript files modular
- Use consistent naming conventions
- Separate concerns (UI logic, data handling, etc.)

# Component Guidelines

- Follow component lifecycle best practices
- Handle events properly
- Manage state consistently

# Browser Interactions

- Handle async operations properly
- Manage DOM updates efficiently
- Use proper error handling

### BEGIN PROJECT_PYTHON

# NiceGUI Framework

- Do not use ui.run_async as it does not exist in NiceGUI
- For async initialization in **init**, handle the async state synchronously:
  - Set initial state directly in **init**
  - Move async operations to separate methods that are called when needed
  - Use proper async/await in event handlers and callbacks
- Use ui.refreshable for components that need to update
- Prefer data binding (bind_value, bind_value_from) over manual refresh callbacks
- Use props() for button styling (e.g., "dense", "unelevated", "flat")
- Use classes() for layout and spacing (e.g., "w-full", "gap-2", "items-center")

# Storage Architecture

- Use layered storage approach with protocols in storage.py
- DictStorage as base class for dictionary storage
- HabitDataCache for in-memory caching
- Lists reference habits by list_id
- Use save_fn from storage layer
- Explicit save() calls required

# Data Flow

- View layer binds to habit properties
- Changes update in-memory dictionary
- save() persists to database
- Work with main list, not filtered copies

# Storage Types

- SESSION: In-memory demo storage
- USER_DATABASE: SQLite for authenticated users
- USER_DISK: File-based storage

# Logging Configuration

- Default LOG_LEVEL: WARNING
- Use logger.debug for flow tracking
- Use logger.info for state changes
- Use logger.error for error conditions

### BEGIN PROJECT_JAVASCRIPT

# Habit UI Interactions

- Manage habit state updates
- Handle user interactions
- Update visual feedback

# List Management

- Create filtered copies for display
- Keep modifications on main list
- Use filter_habits_by_list() for display only

# Component State

- Handle async operations properly
- Manage component lifecycle
- Update UI state efficiently

### END
